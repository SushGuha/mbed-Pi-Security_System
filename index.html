<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mbed-Pi Security System</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    <style>
        ul {
            list-style-type: none;
        }
    </style>

    <script>
        // Script to make the Navbar sticky
        document.addEventListener("DOMContentLoaded", function(){
        window.addEventListener('scroll', function() {
                if (window.scrollY > 1) {
                    document.getElementById('navbar_top').classList.add('fixed-top');
                    // add padding top to show content behind navbar
                    navbar_height = document.querySelector('.navbar').offsetHeight;
                    document.body.style.paddingTop = navbar_height + 'px';
                } else {
                    document.getElementById('navbar_top').classList.remove('fixed-top');
                    // remove padding top from body
                    document.body.style.paddingTop = '0';
                } 
            });
        }); 
    </script>

    

</head>
<body>
    <nav id="navbar_top" class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Mbed-Pi Security System</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                <a class="nav-link active" aria-current="page" href="#">Home</a>
                </li>
                <li class="nav-item">
                <a class="nav-link active" aria-current="page" target="_blank" rel="noopener noreferrer" href="https://github.com/SushGuha/mbed-Pi-Security_System">GitHub</a>
                </li>
            </ul>
            </div>
        </div>
    </nav>    

    <div style="margin-left: 30px; margin-right: 30px;">

        <div style="display: flex; justify-content: center;">
            <img src="combined.png" style="align-self: center; max-width: 350px;">
        </div>

        <h2 style="margin-top: 20px;">Overview</h2>

        
            <p>
                The Mbed-Pi security system (MPSS) is an embedded security system that uses the mbed LPC1768 microcontroller and a Raspberry Pi. The MPSS is designed with a camera that broadcasts its feed on the local network. It uses an array of microphones to detect abnormal sound levels, and swivel the camera in the direction of the sound. The system is designed to be inexpensive and easy to setup. The following site documents the required components, their physical setup, and the code required to run the MPSS.
            </p>

        <h2 style="margin-top: 30px;">List Of Parts</h2>

            <ul style="margin-left: -30px;">
                <li><a href="https://os.mbed.com/platforms/mbed-LPC1768/" target="_blank" rel="noopener noreferrer">mbed LPC1768</a></li>
                <li><a href="https://www.raspberrypi.org/" target="_blank" rel="noopener noreferrer">Raspberry Pi</a> (Any Raspberry Pi model works, including Pi Zero)</li>
                <li><a href="https://www.adafruit.com/product/2716" target="_blank" rel="noopener noreferrer">SPW2340</a> x 4 - Adafruit Silicon MEMS Microphone</li>
                <li><a href="https://www.pololu.com/product/713" target="_blank" rel="noopener noreferrer">H-Bridge Motor Driver</a></li>
                <li><a href="https://www.amazon.com/s?k=geared+DC+motor&crid=22NQ734FUL54J&sprefix=geared+dc+motor%2Caps%2C152&ref=nb_sb_noss_1" target="_blank" rel="noopener noreferrer">DC Motor with 48:1 gear ratio</a> (The gear ratio is changeable)</li>
                <li><a href="https://www.amazon.com/ZRM-Battery-5-5x2-1-Connector-Arduino/dp/B08P1L6JQT/ref=sr_1_3?crid=2CSMN5TBPG1JK&keywords=4+aa+battery+holder+barrel+jack&qid=1682398618&sprefix=battery+holder+to+barrel+%2Caps%2C99&sr=8-3" target="_blank" rel="noopener noreferrer">Barrel Jack Battery Holder</a></li>
                <li><a href="https://www.amazon.com/Arkare-100V-240V-Replacement-Monitor-Scanner-Raspberry/dp/B09W96X88K/ref=sr_1_3?crid=325X8GD6HMUNQ&keywords=5VDC+2A+AC+adapter&qid=1682444179&sprefix=5vdc+2a+ac+adapter%2Caps%2C224&sr=8-3" target="_blank" rel="noopener noreferrer">Barrel Jack External Supply</a></li>
                <li><a href="https://www.sparkfun.com/products/10811" target="_blank" rel="noopener noreferrer">Barrel Jack Breadboard Adapter</a></li>
                <li><a href="https://www.sparkfun.com/products/12002" target="_blank" rel="noopener noreferrer">Solderless Breadboard</a> x 5</li>
                <li>Breadboard Wires</li>
            </ul>
        
        <h2>Steps</h2>
            <div style="margin-left: 10px;">
                <p>There are four major components for this project: 
                    <ol>
                        <li>
                            Mbed microphone input
                        </li>
                        <li>
                            Mbed motor control
                        </li>
                        <li>
                            Pi camera stream
                        </li>
                        <li>
                            Pi email notficiation system
                        </li>
                        <li>
                            Final Mbed-Pi setup
                        </li>
                    </ol>
                </p>

                <h5>Mbed Microphone Input</h5>
                    <p>The Mbed first needs to be connected to the four SPW2340 microphones to read their inputs.</p>
                    
                    <div style="display: flex; justify-content: flex-start;">
                        <p>Plug in the barrel jack breadboard adapter into the breadboard, and connect the external supply to it. Connect the ground of the power supply to the ground of the mbed. The SPW2340 microphones require 5V inputs, and since there are four microphones, it is safer to connect them to an external supply than to 'VU' on the mbed.</p>
                        <img src="breadboard_adapter.png" style="max-width: 150px; margin-top: -45px;">
                    </div>
                    
                    <p>Plug in each microphone into an individual breadboard, and connect each microphone up to the mbed with the given wiring configuration. Use the Analog In ports 15, 16, 17, and 19. The reason for this will explained later. Point each of the four breadboards in four different directions facing opposite to each other.</p>

                    <img src="microphone_wiring.png">
                    <p><i>SPW2340 Microphone-Mbed Wiring</i></p>
                
                <h6>Code Example - Microphone Input</h6>

                
                    <div>
                        <button id="outer_microphone_code"> Copy to Clipboard</button>
                        <xmp id="microphone_code" style="font-size: small; border-style: solid; border-width: 1px; background: #EEEEFF; align-items: flex-start; cursor: pointer; max-width: 450px;">
    #include "mbed.h"
    //Adafruit MEMs SPW2430 microphone demo
    //LEDs display audio level

    BusOut myleds(LED1,LED2,LED3,LED4);

    class microphone
    {
        public :
            microphone(PinName pin);
            float read();
            operator float ();
        private :
            AnalogIn _pin;
    };

    microphone::microphone (PinName pin):
        _pin(pin)
    {
    }
    
    float microphone::read()
    {
        return _pin.read();
    }

    inline microphone::operator float ()
    {
        return _pin.read();
    }

    microphone mymicrophone(p16);

    int main()
    {
        while(1) {
            //read in, subtract 0.67 DC bias, take 
            // absolute value, and scale up .1Vpp 
            //to 15 for builtin LED display

            myleds = int(abs((mymicrophone - (0.67/3.3)))*500.0);

            //Use an 8kHz audio sample rate (phone quality audio);
            wait(1.0/8000.0);
        }
    }
                        </xmp>
                    </div>

                    <script>
                        
                        document.getElementById("outer_microphone_code").addEventListener("click", displayDate);

                        document.getElementById("microphone_code").addEventListener("click", displayDate);

                        function displayDate() {
                            cpyToClipboardMicrophone("microphone_code");
                        }

                        function cpyToClipboardMicrophone (elementID) {
                            // alert("hello");
                            var copyText = document.getElementById(elementID);

                            // Copy the text inside the text field
                            navigator.clipboard.writeText(copyText.innerText);

                            // Alert the copied text
                            // alert("Copied the text: " + copyText.value);
                        }

                    </script>
                

                <h5>Mbed Motor Control</h5>
                    <p>The Mbed needs to be connected to the motor to control the direction of the Pi camera. This is done using a H-Bridge motor driver since this allows for speed and direction modulation.</p>
                    
                    <p>Connect the mbed and the DC motor to the driver using the wiring steps below:</p>

                    <img src="motor_driver_wiring.jpg" style="max-width: 30%;">
                    <p><i>DC Motor-Driver Wiring</i></p>

                    <p>The Control signal from the Motor Driver is connected to a DigitalOut signal from the mbed. In the code example below, Pin 8 is used. The positive and negative lines from the driver are connected to the positive and ground from the external power supply.</p>

                    <h6>Code Example - Motor Driver</h6>

                
                        <div>
                            <button id="outer_motor_code"> Copy to Clipboard</button>
                            <xmp id="motor_code" style="font-size: small; border-style: solid; border-width: 1px; background: #EEEEFF; align-items: flex-start; cursor: pointer; max-width: 450px;">
    // Sweep the motor speed from
    // full-speed reverse (-1.0) to full speed forwards (1.0)

    #include "mbed.h"
    #include "Motor.h"

    Motor m(p23, p6, p5); // pwm, fwd, rev

    int main() {
        for (float s= -1.0; s < 1.0 ; s += 0.01) {
        m.speed(s); 
        wait(0.02);
        }
    }
                            </xmp>
                        </div>

                        <script>
                            document.getElementById("outer_motor_code").addEventListener("click", displayDate2);

                            document.getElementById("motor_code").addEventListener("click", displayDate2);

                            function displayDate2() {
                                cpyToClipboardMotor("motor_code");
                            }

                            function cpyToClipboardMotor (elementID) {
                                var copyText = document.getElementById(elementID);
                                // Copy the text inside the text field
                                navigator.clipboard.writeText(copyText.innerText);
                            }
                        </script>
                
                <h5>Controlling the motor with microphone input</h5>
                    <p>The Mbed needs to pivot the motor to the direction from which the most sound is coming if the sound exceeds a certain threshold. For this, the current state of the motor needs to be tracked. A state machine is maintained, and the microphones are used as input for the system. The motor controls and microphone inputs are run on separate threads to ensure that controlling the motor does not affect the sample rate of fthe microphone. To use threads, the Mbed RTOS (Real Time Operating System) is used. The RTOS must be imported from the RTOS library. The code is given below.</p>

                    <h6>Code Example - Complete Mbed system code</h6>

                
                        <div>
                            <button id="outer_mbed_code"> Copy to Clipboard</button>
                            <xmp id="mbed_code" style="font-size: small; border-style: solid; border-width: 1px; background: #EEEEFF; align-items: flex-start; cursor: pointer; max-width: 850px;">
    
    
    #include "mbed.h"
    #include "rtos.h"
    #include "Motor.h"



    BusOut myleds(LED1,LED2,LED3,LED4);
    Serial  pc(USBTX, USBRX);

    class microphone
    {
    public :
        microphone(PinName pin);
        float read();
        operator float ();
    private :
        AnalogIn _pin;
    };
    microphone::microphone (PinName pin):
        _pin(pin)
    {
    }
    float microphone::read()
    {
        return _pin.read();
    }
    inline microphone::operator float ()
    {
        return _pin.read();
    }
    // DigitalOut email(p9);
    DigitalIn emailIn(p10);

    microphone micA(p15);
    microphone micB(p16);
    microphone micC(p19);
    microphone micD(p17);

    AnalogOut email(p18);

    // PwmOut motor(p21);
    Motor m(p23, p6, p5); // pwm, fwd, rev

    int motorVal = 0;
    double motorTimePeriod = (1.0 / 8000.0);
    double audioSampleRate = 1.0 / 8000.0;
    double motorWaitPeriodInit = int(0.5 / audioSampleRate);
    double motorWaitPeriod = motorWaitPeriodInit;
    bool motorWaiting = false;
    int micThreshold = 25;
    int micMaxThreshold = 70;
    double motorSpeed = 0.2;
    int currPos = 0; // Assume the default position is 0.
    int nextPos = 0;
    Mutex nextPosMutex;
    // 0 - A
    // 1 - B
    // 2 - C
    // 3 - D
    int offsetCycles = 0;
    // Try using a different thread for the motor controls.
    void motorPosition(void const * argument) {
        while(1) {
            // while(nextPosMutex.trylock()) {
            //     Thread::yield();
            // }
            nextPosMutex.lock();
            if (currPos != nextPos) {
                int numRotations;
                double movementTimePeriod;
                numRotations = abs(nextPos - currPos);
                int signFactor = - (nextPos - currPos) / abs(nextPos - currPos);
                
                double factor;
                // numRotations = 3;
                if (numRotations == 1) {
                    factor = 690.0;
                } else if (numRotations) {
                    factor = 660.0;
                } else {
                    factor = 660.0;
                }
                
                if (offsetCycles == 2) {
                    offsetCycles = 0;
                    factor += 10;
                } else {
                    offsetCycles += 1; 
                }
                movementTimePeriod = 1000.0 * double(numRotations) * double(motorTimePeriod) * factor * (1.0 / motorSpeed);
                m.speed(motorSpeed * signFactor);
                Thread::wait(movementTimePeriod);
                m.speed(0);
                if (currPos == nextPos) {
                    pc.printf("ERROR HERE\n");
                }
                pc.printf("Moving from %d to %d and %d\n", currPos, nextPos, numRotations);
                currPos = nextPos;
            }
            nextPosMutex.unlock();
        }
    }


    int main()
    {
        email = 0.0;
        pc.printf("Beggining current position: %d and next position: %d\n", currPos, nextPos);
        Thread motorThread(motorPosition);
        while(1) {
            email = 0.0;
    //read in, subtract 0.67 DC bias, take absolute value, and scale up .1Vpp to 15 for builtin LED display
            int valueA = int(abs((micA - (0.67/3.3)))*500.0);
            int valueB = int(abs((micB - (0.67/3.3)))*500.0);
            int valueC = int(abs((micC - (0.67/3.3)))*500.0);
            int valueD = int(abs((micD - (0.67/3.3)))*500.0);

            myleds = (valueA + valueB + valueC + valueD) / 4; // Just used as an indicator.

            int maxValueA = 0;
            int maxValueB = 0;
            int maxValueC = 0;
            int maxValueD = 0;
            int highestVal = 0;

            if (motorWaiting) {
                motorWaitPeriod -= 1;
                if (motorWaitPeriod == 0) {
                    motorWaiting = false;
                    motorWaitPeriod = motorWaitPeriodInit;
                }
            }

            if (valueA >= micThreshold && valueA < micMaxThreshold) {
                // pc.printf("MIC-A: %d\n", int(valueA));
                // if (!motorWaiting) {
                //     nextPos = 0;
                //     motorWaiting = true;
                // }
                maxValueA = valueA;
                if (maxValueA > highestVal) {
                    highestVal = maxValueA;
                }
            }
            if (valueB >= micThreshold && valueB < micMaxThreshold) {
                // pc.printf("MIC-B: %d\n", int(valueB));
                // if (!motorWaiting) {
                //     nextPos = 1;
                //     motorWaiting = true;
                // }
                maxValueB = valueB;
                // pc.printf("HERE MATE %d\n", maxValueB);
                if (maxValueB > highestVal) {
                    highestVal = maxValueB;
                    
                }
            }
            if (valueC >= micThreshold && valueC < micMaxThreshold) {
                // pc.printf("MIC-C: %d\n", int(valueC));
                // if (!motorWaiting) {
                //     nextPos = 2;
                //     motorWaiting = true;
                // }
                maxValueC = valueC;
                if (maxValueC > highestVal) {
                    highestVal = maxValueC;
                }
            }
            if (valueD >= micThreshold && valueD < micMaxThreshold) {
                // pc.printf("MIC-D: %d\n", int(valueD));
                // if (!motorWaiting) {
                //     nextPos = 3;
                //     motorWaiting = true;
                // }
                maxValueD = valueD;
                if (maxValueD > highestVal) {
                    highestVal = maxValueD;
                }
            }

            // Ensures that the mic with the highest output is pivoted to
            // not the one that breaks the barrier and comes first in the list above.

            // while (nextPosMutex.trylock()) {
            //     Thread::yield();
            // }
            nextPosMutex.lock();
            // if (!motorWaiting) {
            //     email = 0;
            // }
            if (!motorWaiting && highestVal > micThreshold) {
                if (highestVal == maxValueA) {
                    nextPos = 0;
                } else if (highestVal == maxValueB) {
                    nextPos = 1;
                } else if (highestVal == maxValueC) {
                    nextPos = 2;
                } else {
                    nextPos = 3;
                }
                motorWaiting = true;
                if (currPos != nextPos) {
                    email = 1.0;
                    Thread::wait(0.1 * 1000.0);
                }
            }
            nextPosMutex.unlock();

            if (emailIn == 1) {
                pc.printf("HERE");
            }

            // pc.printf("email value: %d and motorWaiting: %d\n", int(email), motorWaiting);
            //Use an 8kHz audio sample rate (phone quality audio);
            Thread::wait(audioSampleRate * 1000.0);
        }
    }
                            </xmp>
                        </div>

                        <script>
                            document.getElementById("outer_mbed_code").addEventListener("click", displayDate3);

                            document.getElementById("mbed_code").addEventListener("click", displayDate3);

                            function displayDate3() {
                                cpyToClipboardMotor("mbed_code");
                            }

                            function cpyToClipboardMotor (elementID) {
                                var copyText = document.getElementById(elementID);
                                // Copy the text inside the text field
                                navigator.clipboard.writeText(copyText.innerText);
                            }
                        </script>
                <p>The image below shows the setup of the mbed with the four microphones and the H-bridge motor driver. The motor is placed outside the bounds of the picture to make it more accessible to attach the Pi.</p>
                <img src="mbed_setup.jpeg" style="max-width: 50%;">
                        <p><i>Mbed setup with four microphones and the H-bridge</i></p>

                <h5>Pi Camera Stream</h5>
                        <p>The second half of the project involves using the Raspberry Pi to stream the Pi camera footage on the local network. The camera must first be connected to the Pi. For Raspberry Pi 3 and above, this can be done using the camera connector on the Pi board, but for the Pi-Zero, the extension must be used. Once the camera is connected, its feed must be broadcasted on the local network. The code example for this is given below, with a broadcast on port 8000: </p>
               
                        <div>
                            <button id="outer_Pi_code"> Copy to Clipboard</button>
                            <xmp id="Pi_code" style="font-size: small; border-style: solid; border-width: 1px; background: #EEEEFF; align-items: flex-start; cursor: pointer; max-width: 850px;">
    import io
    import picamera
    import logging
    import socketserver
    from threading import Condition
    from http import server
    
    PAGE="""\
    <html>
    <head>
    <title>Raspberry Pi - Camera</title>
    </head>
    <body>
    <center><h1> Raspberry pi - Camera </h1></center>
    <center><img src="stream.mjpg" width="1000" height="600"></center>
    <body style = "background-color: #2c2c2c;">
    </body>
    </html>
    """
    
    class StreamingOutput(object):
        def __init__(self):
            self.frame = None
            self.buffer = io.BytesIO()
            self.condition = Condition()
    
        def write(self, buf):
            if buf.startswith(b'\xff\xd8'):
                # New frame, copy the existing buffer's content and notify all
                # clients it's available
                self.buffer.truncate()
                with self.condition:
                    self.frame = self.buffer.getvalue()
                    self.condition.notify_all()
                self.buffer.seek(0)
            return self.buffer.write(buf)
    
    class StreamingHandler(server.BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path == '/':
                self.send_response(301)
                self.send_header('Location', '/index.html')
                self.end_headers()
            elif self.path == '/index.html':
                content = PAGE.encode('utf-8')
                self.send_response(200)
                self.send_header('Content-Type', 'text/html')
                self.send_header('Content-Length', len(content))
                self.end_headers()
                self.wfile.write(content)
            elif self.path == '/stream.mjpg':
                self.send_response(200)
                self.send_header('Age', 0)
                self.send_header('Cache-Control', 'no-cache, private')
                self.send_header('Pragma', 'no-cache')
                self.send_header('Content-Type', 'multipart/x-mixed-replace; boundary=FRAME')
                self.end_headers()
                try:
                    while True:
                        with output.condition:
                            output.condition.wait()
                            frame = output.frame
                        self.wfile.write(b'--FRAME\r\n')
                        self.send_header('Content-Type', 'image/jpeg')
                        self.send_header('Content-Length', len(frame))
                        self.end_headers()
                        self.wfile.write(frame)
                        self.wfile.write(b'\r\n')
                except Exception as e:
                    logging.warning(
                        'Removed streaming client %s: %s',
                        self.client_address, str(e))
            else:
                self.send_error(404)
                self.end_headers()
    
    class StreamingServer(socketserver.ThreadingMixIn, server.HTTPServer):
        allow_reuse_address = True
        daemon_threads = True
    
    with picamera.PiCamera(resolution='1920x1080', framerate=35) as camera:
        output = StreamingOutput()
        #Uncomment the next line to change your Pi's Camera rotation (in degrees)
        camera.rotation = 180
        camera.exposure_mode = 'auto'
        camera.awb_mode = 'auto'
        camera.start_recording(output, format='mjpeg')
        try:
            address = ('', 8000)
            server = StreamingServer(address, StreamingHandler)
            server.serve_forever()
        finally:
            camera.stop_recording()
    
                                
                            </xmp>
                        </div>

                        <script>
                            document.getElementById("outer_Pi_code").addEventListener("click", displayDate4);

                            document.getElementById("Pi_code").addEventListener("click", displayDate4);

                            function displayDate4() {
                                cpyToClipboardMotor("Pi_code");
                            }

                            function cpyToClipboardMotor (elementID) {
                                var copyText = document.getElementById(elementID);
                                // Copy the text inside the text field
                                navigator.clipboard.writeText(copyText.innerText);
                            }
                        </script>   

                <h5>Pi Email Setup Notification System</h5>
                        <p>The Pi must send an email to the owner of the device when the camera detects an abnormaml sound input. To do this, Node Red is used, and GPIO pin 17 is used as the trigger. An rpi GPIO input is used, and a function module is used to trigger the email node when a signal of '1' is received from Pin-17. The email library must be imported using NodeJS and the Node Package Manager (npm). The following command is used: 
                            <ul>
                                <li> cd ~/,node-red</li>
                                <li>npm install node-red-node-email</li>
                            </ul>
                        Outlook is used as an email service, since it allows for third parties to send and receive emails from the user's inbox. An image of the setup is shown below:
</p>
                        <img src="Node_Red_Setup.jpg" style="max-width: 50%;">
                        <p><i>Node-Red email setup</i></p>
                    <p>To activate the Pi's GPIO, connect an Analog Out pin from the mbed into GPIO Pin 17 on the Pi. Pin 18 was used in this project, and this is reflected in the code example for the mbed mentioned above. To ensure that the Pi can detect the mbed's Analog Out signal, this signal must be kept high for a minimum of 0.1 seconds. For this, the Thread::wait() function is used. An email is sent to the user's inbox, informing them of the noise threshold being exceeded:</p>
                    <img src="Email_Notification.jpg" style="max-width: 50%;">
                        <p><i>Email Notification to inform users of noise threshold detection</i></p>

                

                <h5>Final Mbed-Pi setup</h5>

                <p>
                    This section covers the physical setup of the project, primarily connecting the Mbed and the Pi together, and powering the Pi with a remote power supply. The first step is to secure the Pi camera securely onto the Pi. For this, a thin piece of plastic was taped using double-sided tape to the ethernet port of the Pi-4. The camera was then secured to the top of the plastic board to provide it with a better vantage point.
                </p>

                <p>
                    A wheel was attached to the output of the 48:1 gearbox. Alternatively, a flat plastic or wooden board could be attached. The Pi is then placed on top of, and then secured to the wheel using double sided tape. A picture of this configuration is shown below. Note the position of the camera.
                </p>

                <img src="Pi_setup.jpeg" style="max-width: 50%;">
                <p><i>The setup of the Raspberry Pi.</i></p>

                <p>
                    Note the platform upon which the apparatus sits. The platform helps provide stability to combat the vibrations of the motor. It is also raised, with foam pads on the bottom to prevent the other axle from scraping the surface of the table. 
                </p>

                <p>
                    Also note the wires passing from the mbed breadboard to the Pi. These four wires server three purposes: 
                </p>

                <ol>
                    <li>
                        Provide power to the Pi
                    </li>
                    <li>
                        Create a common ground between the Pi and the mbed
                    </li>
                    <li>
                        Connect the mbed's Analog Out to the Pi's GPIO Input
                    </li>
                </ol>

                <p>
                    The Pi 4 is normally powered by a USB-C power supply. Other Pi models also depend on an external wire and power brick for power input. However, since the Pi will be rotating, the tension in the heavy-duty power cables will hinder the mobility of the setup. Instead, the GPIO header pins are used to power up the Pi since these power cables are lighter, and offer less resistance to the turning motion. Header pins 2 and 4 are connected to the external 5V power supply from the breadboard, and pin 6 is connected to the breadboard ground.
                </p>

                <p>
                    The GPIO pin you set as your input for the Node-Red email notification system (Pin 17 in this case) is then connected to the AnalogOut from the mbed (Pin 18 in this case).
                </p>

                <p>
                    A female-male wire is needed to connect to the Pi header pins. Connecting two of these wires together provides more slack in the system, which makes rotation of the Pi easier. This system can be used since the H-bridge driver allows for bi-directional rotation, and as long as the wires are long enough to handle a 270 degree rotation, the Pi and mbed will stay connected.
                </p>

                <p>
                    The final setup is shown below:
                </p>

                <img src="complete_setup.jpeg" style="max-width: 60%;">
                <p><i>The setup of the project with the Pi and mbed.</i></p>

                <p>
                    A video demo of the working project is shown below:
                </p>

                <video style="width: 65%" controls src="demo_video.mp4">
                </video>

                <p><i>Video demo of the project with claps used to simulate loud noises.</i></p>

                <p style="margin-top: 20px;">Last Updated: 26 April 2023</p>
                <p>Authors: Sushant Guha, Dinyar Islam, Milan Mistry</p>
            </div> <!-- End of main content -->
        
    </div>
    
</body>
</html>